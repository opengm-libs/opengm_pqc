use core::iter::zip;

use crate::sha3::{self, XOF, new_shake256};

use super::{Q, rq::Rq};

// sampleNTT draws a uniformly random nttElement from a stream of uniformly
// random bytes generated by the XOF function, according to FIPS 203,
// Algorithm 7.
pub(crate) fn sample_ntt(a: &mut [i16; 256], rho: &[u8], ii: u8, jj: u8) {
    let mut b = sha3::new_shake128();
    b.absorb(rho).absorb(&[jj, ii]);

    // SampleNTT essentially draws 12 bits at a time from r, interprets them in
    // little-endian, and rejects values higher than q, until it drew 256
    // values. (The rejection rate is approximately 19%.)
    //
    // To do this from a bytes stream, it draws three bytes at a time, and
    // splits them into two uint16 appropriately masked.
    //
    //               r₀              r₁              r₂
    //       |- - - - - - - -|- - - - - - - -|- - - - - - - -|
    //
    //               Uint16(r₀ || r₁)
    //       |- - - - - - - - - - - - - - - -|
    //       |- - - - - - - - - - - -|
    //                   d₁
    //
    //                                Uint16(r₁ || r₂)
    //                       |- - - - - - - - - - - - - - - -|
    //                               |- - - - - - - - - - - -|
    //                                           d₂
    //
    // Note that in little-endian, the rightmost bits are the most significant
    // bits (dropped with a mask) and the leftmost bits are the least
    // significant bits (dropped with a right shift).

    let mut j = 0; // index into a
    let buf = &mut [0u8; 24]; // buffered reads from B
    let mut off = buf.len(); // index into buf, starts in a "buffer fully consumed" state
    loop {
        if off >= buf.len() {
            b.squeeze(buf);
            off = 0
        }

        let d1 = u16::from_le_bytes(buf[off..off + 2].try_into().unwrap()) & 0b1111_1111_1111;
        let d2 = u16::from_le_bytes(buf[off + 1..off + 3].try_into().unwrap()) >> 4;
        off += 3;
        if d1 < Q as u16 {
            a[j] = d1 as i16;
            j += 1;
        }
        if j >= a.len() {
            break;
        }
        if d2 < Q as u16 {
            a[j] = d2 as i16;
            j += 1;
        }
        if j >= a.len() {
            break;
        }
    }
}

#[inline]
pub(crate) fn sample_matrix_ntt<const k: usize>(a: &mut [[Rq; k]; k], rho: &[u8; 32]) {
    for i in 0..k {
        for j in 0..k {
            // FIXME: repeat sha3
            sample_ntt(&mut a[i][j].coeffs, rho, i as u8, j as u8);
        }
    }
}

// samplePolyCBD draws a ringElement from the special Dη distribution given a
// stream of random bytes generated by the PRF function, according to FIPS 203,
// Algorithm 8 and Definition 4.3.
#[inline]
pub(crate) fn sample_poly_cbd_prf<const eta: usize>(f: &mut [i16; 256], s: &[u8], b: u8) {
    if eta == 2 {
        return sample_poly_cbd_prf2(f, s, b);
    } else if eta == 3 {
        return sample_poly_cbd_prf3(f, s, b);
    } else {
        panic!("eta can only be 2 or 3")
    }
}

// eta = 2
pub(crate) fn sample_poly_cbd_prf2(f: &mut [i16; 256], s: &[u8], b: u8) {
    let mut prf = new_shake256();
    prf.absorb(s).absorb(&[b]);
    #[allow(non_snake_case)]
    let mut B = [0u8; 64 * 2];
    prf.squeeze(&mut B);

    for (f, chunk) in zip(f.chunks_exact_mut(16), B.chunks_exact(8)){
        let mut a = u64::from_le_bytes(chunk.try_into().unwrap());
        let mut b = a >> 1;
        a &= 0x5555555555555555;
        b &= 0x5555555555555555;
        a += b;
        b = a >> 2;
        a |= 0xcccccccccccccccc;
        b &= 0x3333333333333333;
        a -= b;
        for fi in f {
            *fi = (a & 0xf) as i16 - 0xc;
            a >>= 4;
        }
    }
}

// eta = 3, use for MLKEM-512
pub(crate) fn sample_poly_cbd_prf3(f: &mut [i16; 256], s: &[u8], b: u8) {
    let mut prf = new_shake256();
    prf.absorb(s).absorb(&[b]);
    #[allow(non_snake_case)]
    let mut B = [0u8; 64 * 3];
    prf.squeeze(&mut B);

    for (f, chunk) in zip(f.chunks_exact_mut(8), B.chunks_exact(6)) {
        // a is u48
        let mut a = (u32::from_le_bytes(chunk[0..4].try_into().unwrap()) as u64)
            | ((u16::from_le_bytes(chunk[4..6].try_into().unwrap()) as u64) << 32);

        const mask0:u64 = 0b001001_001001_001001_001001_001001_001001_001001_001001;
        const mask1:u64 = 0b000111_000111_000111_000111_000111_000111_000111_000111;
        const mask2:u64 = 0b111000_111000_111000_111000_111000_111000_111000_111000;

        let mut b = (a >> 1) & mask0;
        let c = (a >> 2) & mask0;
        a &= mask0;

        a += b + c;
        b = a >> 3;
        a |= mask2;
        b &= mask1;
        a -= b;
        for fi in f {
            *fi = (a & 0b111111) as i16 - 0b111000;
            a >>= 6;
        }
    }
}

#[cfg(test)]
mod tests {
    use rand::Rng;

    use crate::{mlkem::Q, sha3::*};

    use super::sample_poly_cbd_prf2;

    fn sample_poly_cbd_prf2_std(f: &mut [i16; 256], s: &[u8], b: u8) {
        let mut prf = new_shake256();
        prf.absorb(s).absorb(&[b]);

        #[allow(non_snake_case)]
        let mut B = [0u8; 64 * 2];
        prf.squeeze(&mut B);

        // TODO
        let mut i = 0;
        while i < 256 {
            let b = B[i / 2];
            let (b_7, b_6, b_5, b_4) = (b >> 7, b >> 6 & 1, b >> 5 & 1, b >> 4 & 1);
            let (b_3, b_2, b_1, b_0) = (b >> 3 & 1, b >> 2 & 1, b >> 1 & 1, b & 1);
            f[i] = (b_0 + b_1) as i16 - (b_2 + b_3) as i16;
            f[i + 1] = (b_4 + b_5) as i16 - (b_6 + b_7) as i16;
            i += 2;
        }
    }

    #[test]
    fn test_cbd2() {
        let mut rng = rand::rng();
        let s: [u8; 32] = rng.random();
        let b: u8 = rng.random();

        let mut f1 = [0; 256];
        let mut f2 = [0; 256];
        sample_poly_cbd_prf2_std(&mut f1, &s, b);
        sample_poly_cbd_prf2(&mut f2, &s, b);

        for i in 0..256 {
            assert!((f1[i] - f2[i]) % Q == 0);
        }
    }

    extern crate test;
    use test::Bencher;

    #[bench]
    fn bench_cbd_std(b: &mut Bencher) {
        let mut rng = rand::rng();
        let s: [u8; 32] = rng.random();
        let bb: u8 = rng.random();

        let mut f = [0; 256];

        b.iter(|| {
            // test mlkem::sample::tests::bench_cbd_std ... bench:      23,167.84 ns/iter (+/- 415.60)
            test::black_box({
                for _ in 0..100 {
                    sample_poly_cbd_prf2_std(&mut f, &s, bb);
                }
            });
        });
    }

    #[bench]
    fn bench_cbd(b: &mut Bencher) {
        let mut rng = rand::rng();
        let s: [u8; 32] = rng.random();
        let bb: u8 = rng.random();

        let mut f = [0; 256];

        b.iter(|| {
            // test mlkem::sample::tests::bench_cbd     ... bench:      24,986.74 ns/iter (+/- 758.57)
            test::black_box({
                for _ in 0..100 {
                    sample_poly_cbd_prf2(&mut f, &s, bb);
                }
            });
        });
    }
}
