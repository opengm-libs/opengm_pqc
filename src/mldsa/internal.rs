use core::iter::zip;

use crate::sha3::XOF;

use super::auxiliary::*;
use super::hash::H;
use super::reduce::mod_q;
use super::util::{bitlen, vec_norm_less_than};
use super::{N, Q, d};
use super::{hash::new_h, rq::Rq};

// note that d = 13 for all
#[derive(Clone)]
pub struct PublicKey<const k: usize, const l: usize> {
    pub rho: [u8; 32],
    pub t1: [Rq; k],
    pub A: [[Rq; l]; k],
}

#[derive(Clone)]
pub struct PrivateKey<const k: usize, const l: usize> {
    // rho: [u8; 32],
    pub(crate) pk: PublicKey<k, l>,

    pub(crate) K: [u8; 32],
    pub(crate) tr: [u8; 64], // H(pk,64)

    // in ntt form.
    pub(crate) s1_: [Rq; l],
    pub(crate) s2_: [Rq; k],
    pub(crate) t0_: [Rq; k],
    // A: [[Rq; l]; k],
}

pub struct Signature<const k: usize, const l: usize, const lambda: usize>
where
    [(); lambda / 4]:,
{
    pub(crate) c_wave: [u8; lambda / 4],
    pub(crate) z: [Rq; l],
    pub(crate) h: [[u8; N]; k],
}

impl<const k: usize, const l: usize> Default for PublicKey<k, l> {
    fn default() -> Self {
        Self {
            rho: Default::default(),
            t1: [Rq::default(); k],
            A: [[Rq::default(); l]; k],
        }
    }
}

impl<const k: usize, const l: usize> PublicKey<k, l> {
    pub(crate) fn pk_encode_(&self) -> [u8; 32 + 320 * k] {
        let mut b = [0; 32 + 320 * k];
        self.pk_encode_inplace_(&mut b);
        b
    }

    // rho || t1, each i32 packed to 10bits, and a Rq packed to 250*10/8 = 320 Bytes.
    pub(crate) fn pk_encode_inplace_(&self, b: &mut [u8; 32 + 320 * k]) {
        b[..32].copy_from_slice(&self.rho);

        for (i, t) in self.t1.iter().enumerate() {
            simple_bit_pack(&mut b[32 + 320 * i..32 + 320 * (i + 1)], t, 10)
        }
    }

    pub(crate) fn pk_decode_(b: &[u8; 32 + 320 * k]) -> PublicKey<k, l> {
        let mut pk = PublicKey::default();
        pk.rho.copy_from_slice(&b[0..32]);

        for (i, t) in pk.t1.iter_mut().enumerate() {
            simple_bit_unpack(t, &b[32 + 320 * i..32 + 320 * (i + 1)], 10);
        }

        pk
    }
}

impl<const k: usize, const l: usize> Default for PrivateKey<k, l> {
    fn default() -> Self {
        Self {
            pk: PublicKey::default(),
            K: [0; 32],
            tr: [0; 64],

            // s1, s2, t0 are in ntt form.
            s1_: [Rq::default(); l],
            s2_: [Rq::default(); k],
            t0_: [Rq::default(); k],
        }
    }
}

impl<const k: usize, const l: usize> PrivateKey<k, l> {
    pub(crate) fn sk_encode_<const eta: usize>(&self) -> [u8; 128 + 32 * ((k + l) * bitlen(2 * eta) + 13 * k)] {
        let mut b = [0u8; 128 + 32 * ((k + l) * bitlen(2 * eta) + 13 * k)];
        self.sk_encode_inplace_(&mut b);
        b
    }

    // rho || K || tr || s1 || s2 || t0,
    // each i32 packed to 10bits, and a Rq packed to 250*10/8 = 320 Bytes.
    pub(crate) fn sk_encode_inplace_<const eta: usize>(
        &self,
        b: &mut [u8; 128 + 32 * ((k + l) * bitlen(2 * eta) + 13 * k)],
    ) {
        b[..32].copy_from_slice(&self.pk.rho);
        b[32..64].copy_from_slice(&self.K);
        b[64..128].copy_from_slice(&self.tr);

        let mut p = &mut b[128..];
        let eta_bitlen = bitlen(2 * eta);

        for s1 in &self.s1_ {
            let mut s1 = s1.clone();
            s1.ntt_inverse_raw();
            s1.mods_q();
            bit_pack::<eta, eta>(p, &s1);
            p = &mut p[eta_bitlen * 32..];
        }

        for s2 in &self.s2_ {
            let mut s2 = s2.clone();
            s2.ntt_inverse_raw();
            s2.mods_q();
            bit_pack::<eta, eta>(p, &s2);
            p = &mut p[eta_bitlen * 32..];
        }

        for t in &self.t0_ {
            let mut t = t.clone();
            t.ntt_inverse_raw();
            bit_pack::<4095, 4096>(p, &t);
            p = &mut p[13 * 32..];
        }
    }

    pub(crate) fn sk_decode_<const eta: usize>(
        b: &[u8; 128 + 32 * ((k + l) * bitlen(2 * eta) + 13 * k)],
    ) -> PrivateKey<k, l> {
        let eta_bitlen = bitlen(2 * eta);

        let mut sk = PrivateKey::default();
        sk.pk.rho.copy_from_slice(&b[0..32]);
        sk.K.copy_from_slice(&b[32..64]);
        sk.tr.copy_from_slice(&b[64..128]);

        expand_a(&mut sk.pk.A, &sk.pk.rho);

        let mut p = &b[128..];

        for t in &mut sk.s1_ {
            bit_unpack::<eta, eta>(t, p);
            t.ntt();
            p = &p[eta_bitlen * 32..];
        }

        for t in &mut sk.s2_ {
            bit_unpack::<eta, eta>(t, p);
            t.ntt();
            t.mod_q();
            p = &p[eta_bitlen * 32..];
        }

        for t in &mut sk.t0_ {
            bit_unpack::<4095, 4096>(t, p);
            t.mod_q();
            t.ntt();
            t.mod_q();
            p = &p[13 * 32..];
        }
        sk
    }

    pub(crate) fn public_key_ref_(&self) -> &PublicKey<k, l> {
        &self.pk
    }

    pub(crate) fn public_key_(&self) -> PublicKey<k, l> {
        self.pk.clone()
    }
}

impl<const k: usize, const l: usize, const lambda: usize> Default for Signature<k, l, lambda>
where
    [(); lambda / 4]:,
{
    fn default() -> Self {
        Self {
            c_wave: [0; lambda / 4],
            z: [Rq::default(); l],
            h: [[0; N]; k],
        }
    }
}

impl<const k: usize, const l: usize, const lambda: usize> Signature<k, l, lambda>
where
    [(); lambda / 4]:,
{
    pub(crate) fn sig_encode_<const gamma1: usize, const omega: usize>(
        &self,
    ) -> [u8; lambda / 4 + l * 32 * (1 + bitlen(gamma1 - 1)) + omega + k]
    where
        [(); omega + k]:,
    {
        let mut b = [0u8; lambda / 4 + l * 32 * (1 + bitlen(gamma1 - 1)) + omega + k];
        self.sig_encode_inplace_(&mut b);
        b
    }

    pub(crate) fn sig_encode_inplace_<const gamma1: usize, const omega: usize>(
        &self,
        b: &mut [u8; lambda / 4 + l * 32 * (1 + bitlen(gamma1 - 1)) + omega + k],
    ) where
        [(); omega + k]:,
    {
        b[..lambda / 4].copy_from_slice(&self.c_wave);
        let bitlength = bitlen(2 * gamma1 - 1);

        let mut p = &mut b[lambda / 4..];
        for z in &self.z {
            bit_pack::<{ gamma1 - 1 }, gamma1>(p, z);
            p = &mut p[32 * bitlength..];
        }

        hint_bit_pack::<k, omega>(p.try_into().unwrap(), &self.h);
    }

    pub(crate) fn sig_decode_<const gamma1: usize, const omega: usize>(
        b: &[u8; lambda / 4 + l * 32 * (1 + bitlen(gamma1 - 1)) + omega + k],
    ) -> Option<Self>
    where
        [(); omega + k]:,
    {
        let mut sig = Signature::default();
        let bitlength = bitlen(2 * gamma1 - 1);

        sig.c_wave.copy_from_slice(&b[..lambda / 4]);
        let mut p = &b[lambda / 4..];
        for z in &mut sig.z {
            bit_unpack::<{ gamma1 - 1 }, gamma1>(z, p);
            p = &p[32 * bitlength..];
        }
        if hint_bit_unpack::<k, omega>(&mut sig.h, p.try_into().unwrap()) {
            Some(sig)
        } else {
            None
        }
    }
}

pub(crate) fn keygen_internal<const k: usize, const l: usize, const eta: usize>(xi: &[u8; 32]) -> PrivateKey<k, l>
where
    [(); 32 + 32 * k * bitlen(Q as usize - 1) - d]:,
    [(); 32 + 320 * k]:,
{
    let mut sk = PrivateKey::default();

    let mut rho_prime = [0; 64];

    let mut h = new_h();
    h.absorb(xi).absorb(&[k as u8, l as u8]);
    h.squeeze(&mut sk.pk.rho).squeeze(&mut rho_prime).squeeze(&mut sk.K);

    expand_a::<k, l>(&mut sk.pk.A, &sk.pk.rho);

    expand_s::<k, l, eta>(&mut sk.s1_, &mut sk.s2_, &rho_prime);

    // NTT(s1)
    for s1 in &mut sk.s1_ {
        s1.ntt();
    }

    // t = ntt(s2)
    let mut t = [Rq::default(); k];
    for i in 0..k {
        t[i].dot_mul(&sk.pk.A[i], &sk.s1_);
        t[i].ntt_inverse();
        t[i].add_assign(&sk.s2_[i]);
    }

    for i in 0..k {
        for j in 0..N {
            (sk.t0_[i][j], sk.pk.t1[i][j]) = power2_round(mod_q(t[i][j]))
        }
    }
    //note: s2 is in ntt form
    for s2 in &mut sk.s2_ {
        s2.ntt();
    }

    for t0 in &mut sk.t0_ {
        t0.ntt();
        t0.mod_q();
    }

    H(&mut sk.tr, &sk.pk.pk_encode_());

    sk
}

impl<const k: usize, const l: usize> PrivateKey<k, l> {
    pub(crate) fn sign_internal_<
        const gamma1: usize,
        const gamma2: usize,
        const lambda: usize,
        const tau: usize,
        const beta: usize,
        const omega: usize,
    >(
        &self,
        m: &[u8],
        rnd: &[u8; 32],
    ) -> Signature<k, l, lambda>
    where
        [(); 32 * k * bitlen((Q as usize - 1) / (2 * gamma2) - 1)]:,
        [(); lambda / 4]:,
    {
        let mut mu = [0; 64];
        let mut h = new_h();
        h.absorb(&self.tr).absorb(m).squeeze(&mut mu);

        let mut rho_pp = [0; 64];
        h.init().absorb(&self.K).absorb(rnd).absorb(&mu).squeeze(&mut rho_pp);

        let mut kappa: usize = 0;
        let mut y = [Rq::default(); l];
        let mut y_ = [Rq::default(); l];
        let mut w = [Rq::default(); k];
        let mut w_cs2 = [Rq::default(); k];
        let mut w1 = [Rq::default(); k];
        let mut r0 = [Rq::default(); k];
        let mut ct0 = [Rq::default(); k];
        let mut h = [[0u8; N]; k];
        let mut c_tilde = [0u8; lambda / 4];
        loop {
            expand_mask::<k, l, gamma1>(&mut y, &rho_pp, kappa as u16);

            for i in 0..l {
                y_[i] = y[i];
                y_[i].ntt();
            }

            // w = A*y
            // w1 = HighBits(w)
            for i in 0..k {
                w[i].dot_mul(&self.pk.A[i], &y_);
                w[i].ntt_inverse();
                for j in 0..N {
                    w1[i].coeffs[j] = high_bits::<gamma2>(w[i].coeffs[j]);
                }
            }

            let mut shake = new_h();

            let mut b = [0u8; 32 * k * bitlen((Q as usize - 1) / (2 * gamma2) - 1)];

            w1_encode::<k, gamma2>(&mut b, &w1);

            shake.absorb(&mu).absorb(&b).squeeze(&mut c_tilde);
            let mut c = Rq::default();
            sample_in_ball::<tau>(&mut c, &c_tilde);
            c.ntt();

            let mut cs1 = [Rq::default(); l];
            let mut cs2 = [Rq::default(); k];
            for i in 0..l {
                cs1[i].mul(&c, &self.s1_[i]);
                cs1[i].ntt_inverse();
            }
            for i in 0..k {
                cs2[i].mul(&c, &self.s2_[i]);
                cs2[i].ntt_inverse();
            }

            // z = y + <<cs1>>
            let z = &mut y;
            for i in 0..l {
                z[i].add_assign(&cs1[i]);
                z[i].mods_q();
            }

            // r0 = low_bits(w-cs2)

            for i in 0..k {
                w_cs2[i].sub(&w[i], &cs2[i]);
                for j in 0..N {
                    r0[i][j] = low_bits::<gamma2>(w_cs2[i][j]);
                }
            }

            // check
            if !vec_norm_less_than(z, (gamma1 - beta) as i32) || !vec_norm_less_than(&r0, (gamma2 - beta) as i32) {
                kappa += l;
                continue;
            }

            for i in 0..k {
                ct0[i].mul(&c, &self.t0_[i]);
                ct0[i].ntt_inverse();
            }

            let mut hw = 0;
            // make hint
            for i in 0..k {
                for j in 0..N {
                    let a = -ct0[i].coeffs[j];
                    let b = w_cs2[i].coeffs[j] + ct0[i].coeffs[j];
                    h[i][j] = make_hint::<gamma2>(a, b);
                    hw += h[i][j] as usize;
                }
            }

            if hw > omega {
                kappa += l;
                continue;
            }
            if !vec_norm_less_than(&ct0, gamma2 as i32) {
                kappa += l;
                continue;
            }
            break;
        }
        Signature {
            c_wave: c_tilde,
            z: y,
            h: h,
        }
    }
}

impl<const k: usize, const l: usize> PublicKey<k, l> {
    pub(crate) fn verify_internal_<
        const gamma1: usize,
        const gamma2: usize,
        const lambda: usize,
        const tau: usize,
        const beta: usize,
    >(
        &self,
        m: &[u8],
        sig: &Signature<k, l, lambda>,
    ) -> bool
    where
        [(); lambda / 4]:,
        [(); 32 + 320 * k]:,
        [(); 32 * k * bitlen((Q as usize - 1) / (2 * gamma2) - 1)]:,
    {
        let mut A = [[Rq::default(); l]; k];
        expand_a::<k, l>(&mut A, &self.rho);

        let mut tr = [0; 64];
        let mut mu = [0; 64];
        H(&mut tr, &self.pk_encode_());
        new_h().absorb(&tr).absorb(m).squeeze(&mut mu);

        let mut c = Rq::default();
        sample_in_ball::<tau>(&mut c, &sig.c_wave);
        c.ntt();

        if !vec_norm_less_than(&sig.z, (gamma1 - beta) as i32) {
            return false;
        }

        // ntt(z)
        let mut z = [Rq::default(); l];
        for (a, b) in zip(&mut z, &sig.z) {
            *a = *b;
            a.ntt();
        }
        // ntt(c * t1*2^d)
        let mut t1 = [Rq::default(); k];
        for (a, b) in zip(&mut t1, &self.t1) {
            *a = *b;
            for j in 0..N {
                a[j] <<= d;
            }
            a.ntt();
            a.mul_assign(&c);
        }

        let mut w_approx = [Rq::default(); k];
        let mut w1 = [Rq::default(); k];
        for i in 0..k {
            w_approx[i].dot_mul(&A[i], &z);
            w_approx[i].sub_assign(&t1[i]);
            w_approx[i].ntt_inverse();
            w_approx[i].mod_q();

            for j in 0..N {
                w1[i].coeffs[j] = use_hint::<gamma2>(sig.h[i][j], w_approx[i].coeffs[j]);
            }
        }

        let mut c_prime = [0; lambda / 4];
        let mut w1_encode_bytes = [0u8; 32 * k * bitlen((Q as usize - 1) / (2 * gamma2) - 1)];
        w1_encode::<k, gamma2>(&mut w1_encode_bytes, &w1);
        new_h().absorb(&mu).absorb(&w1_encode_bytes).squeeze(&mut c_prime);

        for (a, b) in zip(sig.c_wave, c_prime) {
            if a != b {
                return false;
            }
        }
        true
    }
}

#[cfg(test)]
mod tests_kat {

    use hex_literal::hex;

    use super::{PrivateKey, keygen_internal};

    use crate::mldsa::mldsa44::*;

    #[test]
    fn test_keygen_internal() {
        let xi: [u8; 32] = hex!("93EF2E6EF1FB08999D142ABE0295482370D3F43BDB254A78E2B0D5168ECA065F");
        let wanted_pk = hex!(
            "BC5FF810EB089048B8AB3020A7BD3B16C0E0CA3D6B97E4646C2CCAE0BBF19EF7230A19D75ADBDED52DB855E252A719FCBD147BA67B2FAD14ED0E68FDFE8C65BADEACB0911193ADFA8794D78F8E3D662A1C49DA819FD959E7F078F203C456F8B6E7C9415898E541C73032DBD619EAF60F8D64F8683DA99ECA51220B0ACA28464099F547C02777BD37D84A59BD37ED7A8A92633C75D07C793FE7252B584ABF6A15EE14507E5E193F89864D09AC8727A6D0421F0C19F0E2FBFC213D3FBD70F4F9762CECFF231E9C8A7628D3F8B0857B032D32DE62FF8ECBF4008289BF34403665F81A081AD5A85A282F99BAB9E5385AFBCCCF44B74C0196C7545527EC3026DA1280C4EB37D09CFE3EC4B4910B62EB9815A425C6590FC4AD3FBB225752CC1FC5693F187E7DEC4EEFBEB6B91BD91C5E2EA6A91D14D097BE203FBA0BF937C97507DC007C4CAA9B0785892966FF15900924E579D4FBA02BDA87555F073DAE00513E70809ABBC711FBA2E7649577C42AFDC24BF7413E51268AD6DB6113B7D9191AF9D061DBDED5D630877650C124F11BC4BDC3FDC6A900F63126F921E838AD0C2275A3389A39BD99A134504550101CD3E95E6D1496BE7DE6627DF4FD6C28BBF40B30EFA9B5C3D5C85AB14A65C02D6D4781FF13D328608554B6D15ED91289A6D55AAC0C38E37706F7355E9A4FDA615B875926BFE5A59D9EF273BF94A07CFA573178F0E004B6E1EF0A8349E9BCC01981F2460F0A2743C28D1E138FFB765E7E3397B7913335D402FE91806AA8FC819253AF32692FA651E867F5907EF46F00625A030EC904EDAB21426D59119D2CAA43BD935DEC0A550C61EE4B279C1CA3A79C79A66E3F2D2FADB00F59A3A438AA44570106073017FA1C8757500109720D125BBA231A0C36350C78086DFDC8D613AECA88C4CCAEB4A44D13ADB3C717D65C82A351B9B6EABF6A10F4B4E9623E3A95B4D40A12A818AC6B3822DB82FB05DC4202648B4454689AEB69EA325F03E35DEFA54708481420C6D697BB912FCA0D3F192EF297DFE77FF36B2103F1AD1AEECED1C814C2CD7EF16BCE476AD04F941AFC79E3295474A41062518C0037860934F0E5E652F72749A698632A0991F613F5CB96CA1178F974F2C4AA0CE63DC24E364C92A643B90A5F85A62FD4D8D2B193D29B18BEDE2653FC5D3F24F5B2C018DBBCB6EF00F305BF93666BD47FEA9193BC233DB39121442E938DA5DD07EE6E879C5B9DFF41ECEE5E0589AE6175FF5EC6F6D2629F56B18B4DE66FCB13DF0400A797C92270F69BDEBDDCB88C4248919B56CDA70B8AC4F9429C292DA94D6478280764FE2386FC38CB0931458839EF4E7DE8F0689D99805988C7F96111852C8929E5A540D3B78D712DECC396FEF3EC34402184E4FD29F363EA80F6FC50BA9A11351ACEEA8FE68D541E1AA5848D9F6E61DFB62B2F23BC5081E82F76226E03284982EC48481209B1A7D4C8797E44BFA870B22004DB74BD7D478D5B3614D2B1DA7502B398EB9DA80D06461E90E03060446AB4A8238432BFAF752F391791214F1E6B63590D536060D1C245307BC5C1BAC4AAA099D36BB6DCBC973CF2E69F2734D0F29AEEC4567B99A16BC17C6CDDACEFE49927FB14E7D98DD4263519469CCA3DB4679A68CEEDA955592210FC49AA5FBE934CC73D84E4BA5478002D6890989068EF8FC98C2532B83BF3CB9EF02893C2152426B9D1A94734DFB4F91135143C9EED18FD51AE875D07A23775606A734FBA98C063B4A1622E7FF21AA7E652A3D6C19FE0DC6761B7D35302BF214D3079F76051082A875929920DC3B3CB43211A23A43A50332FAF1AC2191E717125F63E2586C4D86DCA6BCD3D038F9D3A7B66CBC7DF34"
        );
        let wanted_sk = hex!(
            "BC5FF810EB089048B8AB3020A7BD3B16C0E0CA3D6B97E4646C2CCAE0BBF19EF7BA2B57C446556EE2B72C78B96BB7A8503DE40AFB54184E3B5463C21AF7485323DF98F0160AE5D137512725F89D563BC9A189D31D20B3B3C8FFAAF5E486E79051F6F3605CCA2569FDB46B3318D23842CE40D6438613F68B455B0D3BCA0E050D4D119988A2C4801B9084E0B048C928092230902406499840655A268ADA3290DA4808228190C81461DC166A21478E08B221E308681A024414C665E1987190C6690C1544C9A011CC347183404500124D91080083368412854CCC0041099070189500A2B2859426410B00410AB980C0C6100C3329A3A6281C26101A374913358A0B292E82A2708B38499404809B2610A4803004370C48B26004172E194964C8C4641A966010836D2038224906081BB72001484DE110490838444C168E04B22C0991508336065C028C8A38051AB58182C00951127222100D04082AA4841058085208260A02B62D8A120E14221048440A1423915040900A2792A4B060088411C4402263462ADAA690C1B230501000A0B46C53B45013058D02310E08201091C84C22A750C2A67092464163168C8400110B81901383712185301B1846A310841443408098250C272C944241A2884502130544B644522292D080504BA60484367009B24D19A88424934994A28049B448912864A1C8654B82859330066312661037014A408018189044C40D4B2881A20640D4302C1B964CE1B260442841D8306524090464008963C224C0004992165223C129422691D038318328284C28611AB28880262D0C19525B22608A9228A21890D94252CB408E9B16064BC805E0066C49C225D422691411691C34900C858D1C8449631085083489581666A038680BA250E08461C1266EC9146AC0C03184182EDC16521418910A392C83A68D12296292A66008A510D9C84D2448248398241A4442080848C8962DA110206024519C3011DBC804112251180468E2244E10C40D18372911B78443848D54407064807021B04D0026620045251B838484807019B0040AC928CA80051B214ED4B0498C966CD0962548327254120509988C8A326DC0043163C861C8C2689BB48C5BC02DC3A88D1B166CD8964198340244142CD386440A188A1A46921AB7084C342421910D9A962DCB242292860898A050DA446A19B1058B206E24C481C99840221932110569D3949108A771DBC07002B82883B449A0448A0BB4106102481CA611E3206640B47003B6046048215B21833988DB674A61E7C208DEBE8DAE4119AFB02661A69ABC8BDD245B5D0FB1A26701C9B9C9A8F7D9FCD4C287FF3D608CF258282A1EB29F9304E89C14F3E1CE5612891C602934526006C99B4AA2399BF494BCF8DF61D6DF4C69BC93E02D4995E2F76E9FDA4EF67EB7256CA89A3F38FEB2E9DF6A010DC1C15002FBD456FAE884821A34166B0658A2412595718E149BBC6E220AEE268D4D8218C25F6A957DE5B26CEA7B14CB320D89E1699AD9F2B389C67EF93386A2C65F2C32233367D76AE4AB2ABBD422E98E493DCC3CC5DAF689B65CC4BC3FA51C9C59EEAF0755170C2495804D02A607C5BF887CD86A0389F28FC9725EF46003F13B0187684BEAB1F24A29F5319601F309C91D2A333D1B88DF205A5120C4CFDC2238124E4E2B47D0B5E66A654FE4CCCB078F07CBD455D15D3EEC7DA274D24A2E571884DE41C3A9A4FDB3F6098A172C30968039BD0E4EB3E2FB6D6EEED39E0B6362D54E7B88959869DDD5D873D9652401A29F27A28EA66D32CCB0EF3BF4600F7557EE8D54BF1DAD18F45DDCD4C9ED57B13E445BF122A43F53940389BF8714FFAC721E59317E4B70500AD0D1B9A627054D3193208C774E0B20ED041A8C055E75EECD3738F007158FADDFCA5F43562D636A5ACF3A3983D3CFEBCA10B813F9F6526519199A0313CD1DE13F06AD5386E1E120795FD267B7F42019D84DF6CD1BF91930FCA7AFD52E80700F4CF5CDC38A5F7A5749791C2FDFFC4A10753C24DB19E8EB651C5B363200F0B5D169947026E9F74F012DC7C5B339DD49D261CA1D37F8F28346E61978054F45AEE436DCCBE7BFAFE07CE9A8B83C90A2686FA95402850925C8582BC9B734E4ECA1F7B20B086F129F277A5CBDAA963C92717EF70EC19BF3DBC6DA203AD90F3B13BBC22FBD980BB1B9D3A34452B3357021CE3613584E0936BF1D09420937815E11CC5D5DDB4BF1D830C4F83F30E515921C784D87BB20C09E3C64BDCE9AB1C69FD307EFE359C7F938566C9F2517B063385167E247F31081119BAC6B55A0BDD71425510FFA2ABDFA888376A37F20C2480152BB361634520007C5B34BF22817CB2E67AC1A82670B71F196C89F23BA314B16A948499304EF5C03DCF58E52BE314863E723C56D3AEB340BFF18ABFA20DC03442030230533D9129B83ED22C351F2328172E363447444AE5C6902B792799F544450787119612E9BB4130A33A2A5962AC09D577D6DDC881FE6616126D8A0A7DF2B2253BC8EC4E35386EA5511F0F15887145B6C23AB3D403339E404073ED9C6A896A2F9EC70C44BD2AEC10FC4360E87636BE155B6A67B7EDF38CF73004813C9E7D2C654C2530A71E5F8C10942FB6D8841535AB1DA43E8CB0BB89E78EC91F8DE1531A03665CCD5A75BDA0ED0E59864EEEF51A83FA553AF662AEE00D1F8367B4D5DDDC345544C6BD514F888E6033C255DB650DA734AD33A3CF84BD3F06FA1A7CA02E4B8E993AE7AE63420A46BA8A3813D1E9D2966BB8560D71C62A044EA94179F4EB1B6ED60719D51E0EEF6CD079152F6BE488EC91911C6D3F1D1173C541F9D25BF342FCAA3FF46C18F2A0441D83BDE3546A9826C3496E06F2F2B0EEB9D5BE8739F83A42D3B300E70EE84DFFFB20764A060212F058C8A5FFA9A34E928D6A7E07708FE5393E3017CE470EB9658A74E4951E6FA4854C9E9C28988812E4418A2E832580B4A270372BC69676889D0CC43240EDABC1D3114D8F35AB2E9EA953082E9536279ACB3BE16D3A205F46CB67B221496935AC04292BBFB9A61C0A03EF4C9B6820495F3D80E4A6FB7E1C69903FA226E023E95BA416DF2E5E4541E15DCC000B5E65C9720DAF696012FA2A6CF758ED6D225A3E4FEE45AC5FB48707FAE133D592CFD2E8C43C2126F652BEE9BAB43A1A10BE2411A6794B26CB55CC217EB7B0B146D23F7922D3222AE5EE8C6D38E8399BA51C681B83816FCF74438825920F9CE8A202A8F6D942DA86238FB4C9F2198EA8DFF81C17286E018DF4B7FE3884D1759E4C59BB52617AED4E78E4E7C4E9A36E4E996D32391A34A0DAAAB6B540815A34D20407AEF81949BE67B906950D89BE9F085E99EB5872695173B3EFACAE9455D2B2CD4F710B872CF662B736216B1BBFB1F5F3D486C7B4B875612333F8E4BA933DC79F0EDFD7BAADE2C16F2146A496F79C42A4D6B5239A30DD3C48BEB092CA0750010F69ED4B92320147DBBE208F6E8EB1CF247D21A3A3B01DF58C0AA62944DA0EF0450E8CE48AA137E7E1516C1D5C86EEA17FDFAC1690746E7267045A3E90596BDB75D50B6DD5C34E5C8D89DC6F2F1D24440E57B4759B8625F72BC4A7B10D519D331F9C400AAE1E50D480CAAE5A1C0FA99D77924CF8DFE56CD7092E7B9"
        );

        let sk = keygen_internal::<k, l, eta>(&xi);

        let pk_encoded = sk.pk.pk_encode_();
        assert_eq!(pk_encoded, wanted_pk);

        let sk_encoded = sk.sk_encode_::<eta>();
        assert_eq!(sk_encoded, wanted_sk);
    }

    #[test]
    fn test_sign_internal() {
        let encoded_sk = hex!(
            "C1623CC91C677078CAC1FE857F7DC40809F390BA0D51BE7BFBAD9B55306FB2E1C5B3DE04C3E7FE3E3B24A41F45F5FDD3E73A72EAED3B3F57356483D7CC102953873F519C79E445456157FDE4EA5F64D613E5ECB8C6258484AFA36AC4D31AF313FC17A5835184087F04CBCB7AE63D41AB1685FA02D1A64F5D0F844F6FB5213DB1C0444190B48DDC04111AB824DC342C19164CCB242803018284C2416206650A280D2020900A83314CC62DE1824C128489E0844518A22D141628D19290D01805490010E284500CB409E11429D2220118A30D10B561249449C2201213B525CBA020DB148DC3280853B0498B34262045919A424910098C89200553A00C12430060C060E33869C4428CD984648C8009C3C844E1886520478060264601140EC1046ACC4045E444921921921AA15023074A022444903470C33250C9384D824249444042809060842811021660C242251C102EC034060BA74D81224C5C286C50A861009388534062A32671524268D42225D9106C08314C231385994608CCA265E222685C804904080013236994864C23A03014184DC0063114488C5AB0850922080A396DD29045242588890286CC18858886700B474CD02461DC86511B932CA38031033764092446811802503671E44624A41632C9868CC236700CC489038910601670428811414042A0A224D92831E344451A2548A30281C024701348224BA06003C38DE1184C59A64954A46810348D4B34815A00215C24018442685B088E920002DB42508A3071A39881811871E4A069A0180603203022C68C8212824A180561A4311402301494691840619A482919868051308414A30C01350D94362DCC220820368624280E623200531045A2388C1039498004465AA86C892682E2C601CA14652340704A246502882520B56508025124248EA42408018270D036804940211834681C862490241018239023406841384D1028718C4226D1B04099249214219140362C0B216689A268A23280014545A0320C89806492466DDA0802D0326E9BC808D2A249E0006D5A226A93B42020364E413669A1124C10A2901CC66D99B26C92442600004A1AC36C9C4221E2B66C58120409850420884D19A930D3347159128D024271C0140603A790D1806C00296D58B8011A29441A308124A58C82B070D2B60021270E48A809248709192585593462A4460C13160E8B844C4AC07154946D22235003244AD0808D83B644CB066289C250C8486811407242C409138268D0B66980B46D52097202586725A9DD16DFD951EFB6F6FE3231A2C471231B53057FD316DB0876691543D51B66FE1CD1ADF7A9A73C97CB74056DEB19AAAE8DAEC4EE2D512F19B5521DF260609A5F1DD23CA4EEBFECAEBC9CB0DD9D612D0AF491655C6B22A2AB52C6BDF09B8C05784D2BE8832EE184F7D7EEC0C15F06052258A5DD658C74DE50D9F351979A1B0E5D4C94832DEB34A09F08422C53BE60568F81F379B76F5C1F85A0E74434942DC524D85C26A8489C273643CDBE8662EE0D7EBE56C7E4AC93D84016D99C0C180D24B6B3A9234E60A01A83DD64446DE5DBF8AA770BDC66097BAD4261AC8878450653F21EC34CD3E6F1303C44A4D29C9E801D6E87DEF63D4D35F7516A992B788913829191A09E9526F8CBC361D6530EDA7EC9013AAC629177CCB744CAAA8ADAC376F0222B97997F273BF7098FC39A63B899CF35D2E9D397F0D2A49D320B03A9FFF21D98D307DFA94A328E04BEE9D58B77C53303779973495E3EDEE49BAB18E3634E23E363E1F46F087D8CFBBBA8A210661C6E790A6A6449E0CC2738DE05A034BFEDD377C0AB454D4F39FA6F4E91FDFCBE621D0AF8F84197B4762CAF6D5992643A16BE5626E52CC0ED24895F629B02D3CFC92E98BEFDB1DC80475FC9EA7A40EFBEF650355B03B76E7887BDBC2D4EF8FBCDD6D95E260FE6561F17C44E1E01F6712DD0E5F7EB89766AF3FC9370A7C168F64746FB8F744D146CA781C6C708A963EB90858930875223CA379428A71D8008C70264C87E420ECF17DC963D3D7E3C8F280A8716EB636FFB857E8AB92847CEAE7C77FD2970DA98D08E001AC9605BDD6A07885B330F04AF2DDDA3EE6E9314C012E3FB14358D67070014A728B6ED5006622052EB43B77EA3E5DDAA0BB1C1C6A973C8A455786A76A673B5F4BDD339258A7218F4A210F0BFA65B4A07EDBB199EE755B8F60CC001026107163EFCEFA41DF85065D46FBA9471513268517F06B5914F0C625F3C40DCFE428853BB58B10FC19C2685007AE56F42CD6730CB4A6283BA4AC4B40AD9D9B2FEA1C2916111C39BAF1430612E569227E2C6AEB11E0451AF81E308F3BD59CBE29D940E2CA1653F6D6C70CB1D3358392F2A97A34FB9BF05203FF507DA2041AFD85E4643A77CFA441963E282B7B2A5A2B8D293D036CB5143F3E01722E589840DFF12186B7D9799A3D74E99288FBCDB6D2CBAD2E5FD4B449AABE16A12924AEBD33AE5F61856EC66F44C0B09FAF4D0C20CD0C59D760368B335CDA9422C695653E06C0E839EA7FE946237B222F61F9F02B3AC916D030560B8ACD07A41E7D54C402FA7CF6983F09D3E46EE6A7F786FA39DC369E0EC4A30BF734C636DAE26D756AA781E40BD1530A0BDD4040AC17329DD6B90534491CB2AE4D179C2215CEB1F466E7D871D42FB21106834D72BBD656D836F09FDFF875B0029D9F3B50BE25BF05D6A2B0EE322E969247609E16D321CC928C3C7F9CAC3C9F53358D066EE23B52837FFDA6CE77D6235DA4FC06869BFFF3FBA209E8255EB6DE7DC40D0C89969DE0D33B5E54151378BD3021C2A8879BBACEF98AC7F542CEF27F8C639FDD3BF0A0194BCA92E46D6AB5C44C7CD960B1409A088304D807AE67442712E3F72171E06FBA8CE1CE2A6A15562F6BD6968D15339233C5BDD9A5A9796C1DF657F08BD90D1EB5126314B16324A63ED2E8486716B38DFDEC3B14BFE21B2D710BC4DF2ED5A45993DFA197E5B190BC11275E5D9B2BBDAD69E819E4FB4EC859B8C6D32D6F21A7CB35E62ABAC2892E0C6C76D6A416FE3E5CE80361204CDD30C584344C3E61BF91A239B626D8C57750CE0FC4BEAB5743F93083BA01FCF2A9B4CE04BB80AD8B3652C28F4A81D96ABF4716E8EB090817710AB2D052366391F1897C7512F221221B2EEAE39D36C24B919CEA2EA7EFC42CA4FD6FEF946BC241106F12FB82B12D947527723E32BF5029EF8E6C6EEC47C54FFA329D8832F43811EF85FF1B2133FB6240849D7435EA99DFA76EC12ACD6E7AD590889441FBAF7278F019849872D9F4A281764005CC34951CA11C2CD1CE31E51CD2C9EA8E4185274188718D56780DA3F7D234FF14422697B3B4B3936BB1607BB9F048A69A293C7C9DF377E380C9EF8B39990E6D7FFCD4FEAD58C1E5249EA58F9ACE95BEFC1A904B6BDC284577D8FB618278D1F132DE15E55A09FA1A558999298A02B3787C5E53B34EE7D017599CEAEFEF80AAE2953E1CEC97E880349C2AEDF507B3AC853EDD5C0D8081500DAA684A20CE3462E1338917748A2869C9708C5A282FB7D66CA0AADA519FC56874D158D8951BC66EDF57EAF987044C7349CAB7C91BEC1655F22006182084F1A65C356CA2AE8AEACE36D3C5EA966C23F047EA10F1681B679"
        );
        let message = hex!(
            "430B1F46E87DDE9A3D055A7D4D6AB1277B2DA6EDA642896412126391AA2B29AFD81C246EC839929F5C06749491DC4D81D58CC989D8500B6879E8807B1C3AA0B199EB599AEB86B344B77E3DB1AA034C938D80CB4BDCC29B31B710F57C7E491D99B71E97DD6FDA01A0D8A54C7481C2786F64FFC53AD358CF31C9C875ED278CEA03F2BF732372B19252BB9FA4ABF465FA2CFD1C08684D10582B410A8E012DBD407C5140D97CEE768C6D68124B2C84113B58C9A2AA67093B44CC3B6199FF1EFA6506CC28BD30BEC4CEA88411A491DD948DDB09ADFB92C40CA50E709840BC1F107E0CA428C111EC4505C5346E74AE4AB5647C1EB80F9C07092F8D39A975C4890317F9C0EF474110AB941949029BF39ADFB8E65CCAC0360A3EFCEB69D2BD805E4FC8D0620F8E039BC046DFEF1ADB03F5995FF62AD41352D479084EF3E302578B83332506918CFAD6E3BA701C94B0138DF0CF6C2948049274CE61EE0A64E756306273A02D68F3C405883F2F668820356812B2DA3A32B9FF23608DFA559183151221F83DCA18253FCA099FE24728F302C8B7808D7AF978299F3EB853A8BECDA46B8657598BE9ECE8A02DD4B25C593DDCB436B82335EF9C6A7B8426B701C66C9EBBFB3C8405A73881DAB57D1664F3AEC6F5BA19155D89A0A80B5D01C46BC79E1D4338A50B203397CD4B16ACD597A7C77C49917E9FE4B0D761065CB89C758498868B14BE2B6FF758745AFDC535EAA605C3F97648034D2A320264150278A7F1CB114B977C9D6BC1F29295CCCA16B23B7709D5608E4095E41D08B22AEC6289ED402414787062B0DA2387B6DEE76B32E42C51788B65E815E089BCF92D778F49A9707D37FCFBDF8CEF953A48A4201FA0173529BA360BFA6A77200F57FD5245146C2CD7FE8882670EE6878386D06036F0E1BA4B728CFB75806F05BA6409C514731B0BA8DA11015A63A8B5B5AB8C69703185191D12C5611F1407E8FFE3E50FC39C3310EF4091BC09FECC11D3AC107C696EE89F74CD6147830B4B3A971A0027747B62C528F6D858D1F9E67F59496C6B4E9E03FF0A598B26625B06C79863B5F07E265A40175E1A6D6EF3F900F3C4A28AD3E49D4D0B7E4ECEBB79244264474CCBFADA43FCD33F4FEBEB0F7E5928479F869D6A0FE52EB0CAC1232D7F674A057DEC4C2248934A40F5E2C9CBFDD53F71FC3BE06E48E13398ED426D8D3CC82118B7E8E5BDCA248380F4E64C427D1BF2384F60F6A07F01EE62AA1746CB143F26412547E7EF0E8FD1F2DC606F3643DEAF330D81CD6309465F9ED7F34D9B175FE1641D90212D4FFFB91CC300E7DFA0C555F7B35D2AF6A343D1467436EEC7AB95F2C34010FC99D66391377770A7DB8CD4D5C6BBF931092322741929F790E037318D6ADB74B4768C11F0E4674D18185DFB3D051725F93800CD38F58688AAC747F885908804D6CADAEDECB43131D75B18FBA2D4BED8D9BCC2156FB23F8F6378C622153EA8301300D0FCDEF1E2BB4E6F807784EA0171E95C372EC19B05A6C7B8DECE7080A057D29CE5A445A83410EB83B174590647424736A3B6967BCDF8A416A51202CE3F00E4D97DCC2C48A78D12CDA98E94A9BD6CCBE09DAF8085304F6911ECED3547DE9512461E16721322E4E6233BC7CA360A9004DA5AE064514603EFF0DF4E2D8EB04E9574C59F3AC14726C10100C688203F4960197CE696730AD7E558D7B939E3E6E7EAC4E70A7F6AAA80C1F1546E282B5CC7AA193213769B137C7F450AE5410817166F29F2E4E7E962932DF282A9F08A1DEF3E19C251F95611DDA9CFF4E2FED873439B45F8451B9AE06C6B2C698778BC4C742708BDB54CB35B686F0E7FC856CDBF977AFB663DFE44F7FCCE0E0555BE81EB28984BAFBD6FED3F0182F78A1396AF7B7081280864E5E4BFD7C52DA28BB5DE5FFA211678D13D41BF825F4B21BE1CBD29719ABA341E7B0C3F101CEDFE2F709E4DA4B5A6D0C021152AB546837024F4DCC4C45C132A038315A0F1D69AE768F70606D070169AE0818685C4BDB7341BFE15AA0455F535766FBEBB50875246A6DAE86C7B9F6F3A9FE01AB9928A99C13E6628431D41C1506381A63FAAB57BFB3B180F5D7FF59A434233EBC5A659B71CAE6970CC838D5FB638676216E3B16E8BA6C01349A7482AAF32ABD17DF7FAB8C69789F0194022BC4E62B6A6AAA4CDEF13B1E3BF5E1F4FA69F82B1EE3FDCC16DDE1106E3D2C41F6E661E33984DE7AD6021EAAD3E64D8C9CD7B5CB538AF88DB82FA048E5705EFDAC0EF479827EDCA0255BA60771A5EBC716C690CD3AC840FB6FF462063503D68C199050BFBD64533D94E093A47658822A25D54CBBFC689DFCBEB1DDD5BC6190B8F02C6FF3D001AC63729D35C8C50FAD3DCA2E67C5CCC6A8799420B159C7C5CACAB958B423964C489DAB1982A4E2222D700BA5AB772C4A11A44FF64018AF477D054217EAE28FB8E37595941FEE7AF87FD44960A144DB0CE2A44B33DC79B1EE31CAF80DAD620666D0ACEA76841EEE6CE81C6FF1F6D1027502EF89F1595065CDEC19B30E4B5314EFD64031B3B9DDFC6C95A4943247ADF7E4C93350C241ECA71260A454707B84017C5EB7AFFEB5DBB863A1CBDE0062C662308A2E824CDF6397863EF78F62319E2873B506F8A9EE82135B803025D962E609E006961EA3F7B67347518E70D9273893D79530F67CB678D6A8D28A0342BAF904BFC0A69AD575CDA4AB73AF22B52AE5D58372E0C26795CA96A16B8461AC61E6F68433ABCEFCBC16B857A89C475D1A322D34266539A17D485B8FA356EC3E154D37BAFC4CE75829FBE8BC823FAFF15A49F847C286F999A1F2C12B03E8F8A4C34A97588D91971279FFCB100EDB943E636F78ABFBAF88BCA5C55C935F6147E51BF798267E1350D2F5E3F74B339F6EFE86208C5BDE149C5B71056BEE748D06614AFEAF6DDA2A6EFFBB56B0880AF9B201B3C12055D292E3BB556240DD031C29A67BF244F59112BFB6865EEEC1DFE1CDB1E27F0A9E3372638FE4407099D0E54E9A188079C8BB9470BE6F63C83612D80BD60C21B251B64236E5CAF09A11C12F1A5E94F199DBC7C9E394C0B0E07A583E707E5241B8FB33E39BB26C31929F39316F4FDE206493566E17B51CE635420493176D8FD353206EF87F0994F039DF8F008AF602F50D7F9C0051B56227F3A2ED20B29611219FC4376234EB900093A81389ED00991272B739389F1F978A92A3E41F0A28985D697C01240875AC46A82B2FE94004CBD7B1E7594AE38A9DA0E84FE7E122482BB391538EB8E85AF9DC022CB32CC08FDA7A95165725EC29A0F824F97F0251BE636B57E0791A7F50EE190D45749472B29A674239AF95B373A40A6E0E09C674071186B125EF5AF72CB434AC0AA990341F063EBFE30963451491474B603733959A23A6D5B8A378F15A5A5B9CE4BA44BAEF6AA531AF5097ADE73F64AED0A541784119665F548FAEB447DE108AB74A74893017F0A1AF84AEF0730B555767B0CF6AE502E7693374D2E01C54C64E411AA93C96DC5FA010267B387299D4376FBB190E1C51A560871B559FC800D82ABD119A5732B50270BEDBCC8A636E7499149AE0E47F736FDB71EBF1995D1E8BDCB0EE96E732E8C2509F98717C3D174C78A4A2BE43DD89195408CD300505A219305809A1BFE7294BC2EECE6D98C768A8A1E0F74B665EE3D652AE8E008EBBB11F0D2148E4E5C93D7FE0190D27B3EBB7D2194BFBB624AF3A894CEF7AED571954D006824950A981F4ADA72BEAA0D820C5DD9BD519D39BB7915681F266DA66D49BDAB9E55879B953A7332F877DC5F5CC7BB3C9E1C1F2E41EB55EFC02A450B5142514F1E06D43E48FBF5DC80DF241169D5936432BFE9BE99DCB17293CF968A17F3111C884635EF2BEDFC87DBB80BF25EE9BF57B55CFE635FD99554F5FF2B4482D1948BD282FA282C48C0302348982E30A772BF14195CAC7FE39F836E6238EB1E1FD074E63B9AD0A8D37111087E47FE5D04B62DEB496353457BC76C53A2FC9D5AC9AE6A47F632E6D45E08786DA128464FF2266BFF92B5CD89176A19226F2EB14CDEB331C497F1836FB6C0A117ED6BAF95E9DB8254487B0DFA7301397AA29D95FF2065D851BD302B747AB47BA0AF408B51E4BBBF042ED1B2B604EEF4C266FE243261515778BC9451A8DFB025FA3212E868C3A078C7CFF65077DE94E50ED90A259FAFAEB398A94FF15C838EFA7F49904BEAFCCECD8C9ED4E014EA00C7AEF1D437DA306E8B7DFCE536912C169BAF0A3B78A643D6E210E5550E3B2BAF7EDFE01E721E3D05BAC1378EC1DFDEB2E2AC0F0BC368E0A8CC64F375DFEA2FC20CBDC515440FC2ABBBCEA3584E103BD686C5403EFE376D44F5242D35C9F9D35E1A869FFCB6657823EA0D4331ADD5CCFA99BD6EB3494A48ABBA7B7ABC32ACB8FF00512E1B0AD493F579898847E328C06FE05FE282F8D4AF48A1AAD0495AF1AC7354275A6D45AD5A7B3F6787F893EA558BC5D4ADDE1F0D265ABF73C86550D25C00821C3138B385448E3E02901E2E6EBC6A0F211CB6F22F8F865F0DF3893B987DD086B6674F5464ACE18B9F0EAE948667B2FC04FECEA3E2B7EA6B869D5F66D02D4DB124A59621B96E0DEFBF99A91AFA0CFD6D5A5968E62EF42B4C8908C3719BA0254929A9A183D50C566CE4FC970E047474490FFB07F576765AC5286B2E0FDBF1EC56A8AE8E6F560C69614FDF5C89BA53B8B7189E6388F7CDF7B819F78F3E6EA54C40865262BD2C8CE87284FEC36E2E73BDB8AA9CB5283272A90A6BBBFC3F7FED5F124E8BFD770B6254CDC695FBA0D8627315370E2CCDB89BCC84C96E20805AAF087F9E9BD1A189F4C6D66A6DC3FEF773788B3B57EF876CFEAE1F2C876CD239BE3B8A94F21350EDAE6C269698CC66BAF90B3641593F96399C71B2ECBE50F61B5D6F37D47DF702A9B9E47BED2824DEB19ADE7D7D8830A8F610088CF4BD0AD22A5A4FBA767D01987688BE710235A74129666FF7917B506A18E6B5D6166E8B682BE6B1946A4D4420926FF8CDF2488EABE71EFA7F2536B9DBEFBA08BB9E94086F55B1B991E18E6023E6952D4A563F2420A1536A1EDDE119E5779223CB712AB5C0BA4F0C176830FE523DD8603F1B316E128579E65454C2BE62C922C1DFE09DFB47D4497CC552AA9987A8BFE19C44E207397204686C718A0936145FC102B8A7111F74A421226AE016EDE658DE5DF9D3C28A247A87F2BC6FECF66CE7A6699880E0871CDB6F066D2CB3F9F625DC5E80751DBBC85982982E2EFAE3AB8F4F1EDA0D13C3B65FD2178E8AE4A712B521B7539785BB058176AB4396E6EFF2FD9052D4C6AF17DC30F50630233C3F05C62E151EECE13CE124E58A25F0F3AB65033ACAC9EA6E41CB3FA435D367DFEB0B9C9B37414CF32DC85A3C43087A578165C86D100E47DBA1FE7061111AAA961E67ED057C715974D3144912A58B6DB22D51BEDF6A8646D810190D91B61F0776DA00C8B0BAA7A83F4433F357E758F5AE8F278119908497E717A7AD25B09EA7C76B306A9A3AFCD9AE6B4F64016D5E80BD3FBE2F5EE673A7459B03AD9356148EA83461B66716346DBE85678C37C932EBC53B033A3F46DC28219880CFA8BB5E15F8862D345923BBC179FD763A0F943FC56BAB69F26C0C15D668BAD923D7AE6B35C07621768F9D972E2D6F46551D45E3FBBB577D13F01E8C1AFDBDD2F052E931C0529380F290FA1DE8BF5A11F82612943BAA2C0D086EBEC84069B271AC8656883F686C67B1808E27C860ECD1B95FF6CC6E6A5846DA29992CBA450081B8C37DD4911470EFF281FE94F10636A29B790E41EA6A342A5BE79CAF575FE9B0147F2EFE02874BC8A0E136A395B42E77D9F18CA4F61501E6C1805CDCDC10D0292593481F7E0F93281D0456EB51F6ABB7C379C028890F445D9FAC0D96AF68CDF6CC879A406CF2F0991916B33A72A193CF170B45AA079DB1BFD4B4126FA9AD3ED13FC98CE4C6C3C30923C8C53BCE1812B21BB644ED3A0CC0596C60032FFB1462DF5182528553AE865BF87FB7C7F61D1FD8E40D830B8D8F54924EDF934D1EBB88DA90BC59EEF1F6BF9FC2D17D8E9E0E39FFAD22EB84EFF39BAA70447B124E492D760E55D6301DCDFBCF9173FE293AC4D6CAF2E1964B32973067EC76BBECC65113C1FAB85375D92CE1436E1D1B205A88202B304264620B282E62CAAF5CFE1169EDAD9459B15BF0060C5744A17460F9FB164974CC55B3FFA71AAC13437BE58325E5E27E151C71D195F886F5630925D441A54695DF23F64C6BC3B0CA83F0E88D01BA4DC748A29F42AC2997C2A21EC258E430032C09E73E73AC2B21B55E1DFB2DBA281426620A0545D2507D1E96A3778C780FE77F1DA3B615E1B0D14DE8729229472E6619AB3B67CCAF21CFBFFD1F237E780927F147425B2142BF62CAD6B467A10F7B3DB922F095A0012EC179C4F8D5437AA8024F13A2A485E8890940DB69FB719B94B7D2629D277B593B94ECC744AA4CFF3D33D2250236C74DA057496BEFDB961B89BD6F44D581AD7A28524A6AF2253FD27530B7FF16FB5804FCA7E44BA2A3AB85FEDEED837DC130F533E8215B3AC3F584A2EC0E9B6194F97741EC050576E16349AD852DE8AAE2BF83CB1894107299F101AD5A2C05EC590B2CC698663C44FC0DC7F893F42BC5A2DECFF2FAF46CC1C00FA7294A0184A85CDDA2B1F38A89B1B17EC08555D082411A4CAEDED562C9FBBC1F512118EEC3BC931CC91636461151BDA454C4F029E01231BF170EBE17C526F3D8F705DC46560642B1AF36E3B401325A6CF59B88BCD4B3242D676FF4066E4252ADCA37786CBDB340DD81C5DD0540992F0B142C5A18D3BD1070719AF996E3C3768C3B234D303E6E9850B35C7AE52496C76106D7CAE4CF8ED01767B6DB5603F339FBAA019B08FA35E3DE1129A6A4D578264CF1FC8A1DBF218DD72B4865214DAA795A00505D4AE2B85E90F589065D65FC60CDD828007D4D3A4C084C7EC159C5D86817860CA03545FF74F17AD8570B2ADA55ECA12BFAB5C10067A086A34A57AAD8694C953137BBE901F8D3DEC27DB5DAD2AC96D56C312E25FE48BDC889373ED252B4F88D32DED6702B58D35A1FB40ABE2F2ABDE21CAA5FD0F67E7407A8"
        );
        let want_sig = hex!(
            "8C94308B9CAEA02AAFC29AB18EC01929A029D49F06F3BB4EA3110B1A9A415C77DF646A68302FFB4D853F8B9AFDD4D46B30ADA30213D763551A2FB98F690296DA77F08B3A1C2363EABE33DB1A891C331932EA22902277F44D68A0001D339C1108C3815A68DD0F7396119FB1DC888E10E3A95182E5A185E9CFB0F76CE84ABC199F7D58C7DE375F74EBC6B3338E3F6C51070336A1D513B3BF6FF4250313A52282D32DC616EA4B2B83A1861024AF9ABA17FE0159544800AEE0534511D9359415A66A6D79C2B3173B6281BFC3C96F07F944CEA0841DDEC3BA1ED9B337ECCBA219C675A13A1466463C128FF79E5C8F1BCE22220E1EBD1A071AEAA32E5506B553176309E1EF15AE7C15BD361EF6676046996132716B5391E9C0350C248A70A3552540963858FDDD3456FDA6707B99C120AFD925A47E4DA492DE65DD041E58A881A8E4125C3CAB474ED7D172F05FFAD0655FB7729AAC1C951AB05892198D713657936808A2E9795488F3F6E3183D0AB6B69B3484AC7B9F3C2AD65AAB9901992FAE9DC1E585D9CF7C71B4C7CEBB47EA07D534F9C869B114E3B0BF29ACC2CA60B91055E98643E7F16D3B4FB0477E3AF62C9BC5535565BAE2B8B276B33DFC50C3A14A62891435DB43DA2861154C654A4429ED865A373C28FF41F0C0ED11A1AB963838FF975EC9754C5FCAE3BAACB9ECDD920E365964DC321147A39653FE4B2F2D1EFBAF8D82B2198376C814FBCAEE96411B9E2D958D64AA731BBC1D6174D6EC139FDC73C9F3AB2886A92E0E82C700DD5A83F5EF0912ABE4CD30E0E3E9C8639C4B329B639DE189D8AAED2250F3BA74C381D6A4D333EDBEC2D1511B20A8144B42F0B5F674F4004F39CE1091BD431ABA3719D994893F4CF798F3CDFAEA9ED0AD5A3BF7DF0BF7E9E716CF2D3C72B17870780C724A0A0A2EED8E5CB4E8D15597DA311A4923BC8F6FDB64B9CCEF2C95BC026994ABA7C743F2FE83D5E771ACC2B6F8AEFCF6E1C7360767B9BF995778F95390C303C88FB81447EE993DDA266F031B9E4907811E3868F883AE4175D95C0B4C61092FDAFD2A41514408811828B3FF30150239C28C1E3E65631B178FA56D019BA08822C038F718BAA7A12FEF65C08A84E2E9D6E292774859574686AB024E2DAA6DEF1BED248EEAA02E0D28C73ECF803A250123636E6B8C642A10C3B8B3DA55706E17ED5EA96B80AA9D99E450513E16ACFE6A587896BF17254B4F420EED062775BD74CBC09ED7F925D10D34FBFB9EEBBEF6DC29ED87BDF01DD57EE8909BC0889BDA2AE430D8CF80E211EEA8C41DFCCE7DCD197352F60CAB92363FE4681DAA0C8F62ADD5FB1874151E1EBD8BC025A8341C46D335DED5293F012E7E9C2A8CA2234E1E5970E6C51C6711ED16494472205878ACCEEFC98850E3AEB99F10B6A07CC3A31CA742F1F93B4104496EEE8DBF0480AB395310ED09D8C7A117AD8A9F5C4A3050807A600613723555189F22ECB98F01ED8E69D113A03923B9C0C8889F094B30BC16792565F3CCF427EE9F0BF24AD436DB5C40E6FB66BC416009DF2F4D422A9C719585D47B95BF274063B64540B672A373073FF87291A62C7B9838446321B71356E7BB5EB096E9EB13B51A50EE891A2412E2117A5275DB0265889D74D9AB9FEE8AD1B039A0EF471F1410AAC97323E30DA2F91FF22D33DC9C8379211A404E32EB01786EA0CBD618821F710F093DD276F52A10416648E52879ED2A7FF6821EC49768D687984397D532C20B7050ADCB4330037D1EA1108B3A98ADFBB5457B05C8027E1E9433BCD89ACA8A84B802634C0759BA1AC6C144097E0EEB0A8E1A3A64E3E66A09D443E49ED53FA8FA8A295AEECB459D4CC32109EB999A4BC3CDD4D744EE7D9A73F07D763B8F80F4BFC63002CA3EAB87319EB69DF4A25FF1A7CDB72A74CDCD2E49B5A9D780ADDF902B9FC31F90AE788AFC954074E010B495885153DA0CDD15B26C6436D077A040165B6454A24B2E2162F9FF31B9C4B9199934A7A1FC78C68704B9BB784B0FA15A84AEA9E70D51000D7F335E450A026AA935533DF695F471739D9924D452B3C3D84DC597442A92E9A5C950C72B80138BD6154214720D8F19EA7E99328770A48069506F22869FC67129656E26E8E85242FB6E93B466B5277E8FB8B235A221A86A1191801B6B2EF236DCF910CE2FA399F8CEF28F148E977B762C8A828D57ED48C95711A479090255308196CD168B3C6C49777FF0E4D2319B1C44954E9A20C07E23F79CF1096DAF01ECEF4D47BA517554FCC1C6D139CD2F9F5754B61963DED55FA7638FE20041D4E689E6256A305AE0BF096EE9ADB9A76EBA46F5183575E8CF70CC6F69E5AD1DE54159E5339D818EDD92A2B9345AD759DB829C6BAB42398922788DAE97AF3F12A4354014F147A27E267495208978D736C632A5F0270C561353B27BE23CEAB57AD68D02F9AA94F301D3FCEF3E6E234BACE92F5D8BB1F975400D0D6B22F1347DB350CDBC71DB4519BBA4FB5C243A91BD0DA06C1155514E45184581815C7229AB66C921F2BC95655CED4A32D128FBB6B8BAFF83708CB49F69502D90BCEB6BD55DBDE19732098D1D1C1A26C74FE56DB0470C5E76BC6F4927A34D6BD84E57233E37127146295E5F19AABB77F9A6F90D702A58CB0EC0648AA54753AFE9140A9A60EF9814E43A916F07043819F09BA02A7A84525C34D3492C67ACA7C5489B72084CA7D1D5CF2A061394FAC77DCA111DAEBB9CF6C1B270A027F8D2EE04E0BB68D6BFA136640D04366864213F9EB3406A747B81EAD497416880A0CFF50F95784C044E58BC0839E6D36FCA9A45374A4059C812EC2B47AF8FC3A99540A62EF1C4B6D75FED8AFE7DCAF37832A02B3BC0339CF41A6F42733A584DA80A8CB328A5E6E59848DC23A0C0332F529853B138ABD0D3F2A8D2FEBC1D71E249E1FFED726E4664FC3020566BB769D4F3CBC8A735FC7309AFF545C3F87560BBE3D5016FC99CCBA9F5410030A86858F320DA5058DB5A188E68164E2349EE036B6904E5229920A7580206D3B75E89A8EED7ABF650D69494A13E83F37F841A4FB2A7F1BA538D40F84F25DBC0EC78DEC1B5F29F1A27198291365257819922F1A42104C721ABC95B2D610B0DB4576401E70B1760184DBC285EDDDD0788DEB108E824A21B8E98F0CD8A60557D183D16162F32C3D7C7353C3DC402A8B96EE8C5408A4D525517F76EF11238DA98E8069402FAA2A9A64350C4AE80F033A52209E66FC36F1802552292F706BB6B703C8E1FD66DF7DE25B4167EBF2E6F8189D8AE114460A1B0C0398CEE7BCE10D022833BEEFCA70D5BD174446CEA2C23DA0426303D45535C5F7E81838F93979DA4BFE71729373C426366787E899CA1ADB1C8D1E5EBED05315F646A798795ADBDDDE5EAFC1A4D6F7884929ADFE4E8EC0000000000000000000000000000000000001225333E"
        );
        let rnd = [0; 32];

        let sk = PrivateKey::<k, l>::sk_decode_::<eta>(&encoded_sk);

        let sig = sk.sign_internal_::<gamma1, gamma2, lambda, tau, beta, omega>(&message, &rnd);

        let sig_bytes = sig.sig_encode_::<gamma1, omega>();
        assert_eq!(sig_bytes, want_sig)
    }
}
#[cfg(test)]
mod tests44 {
    use crate::mldsa::{internal::keygen_internal, mldsa44::*};
    use rand::Rng;

    #[test]
    fn test_sign_verify_internal() {
        let mut rng = rand::rng();
        for _ in 0..1000 {
            let m: [u8; 32] = rng.random();
            let sk = keygen_internal::<k, l, eta>(&rng.random());
            let rnd = rng.random();
            let sig = sk.sign_internal_::<gamma1, gamma2, lambda, tau, beta, omega>(&m, &rnd);
            let result = sk.pk.verify_internal_::<gamma1, gamma2, lambda, tau, beta>(&m, &sig);
            assert!(result);
        }
    }
}

#[cfg(test)]
mod tests87 {
    use crate::mldsa::{internal::keygen_internal, mldsa87::*};
    use rand::Rng;

    #[test]
    fn test_sign_verify_internal() {
        let mut rng = rand::rng();
        for _ in 0..1000 {
            let m: [u8; 32] = rng.random();
            let sk = keygen_internal::<k, l, eta>(&rng.random());
            let rnd = rng.random();
            let sig = sk.sign_internal_::<gamma1, gamma2, lambda, tau, beta, omega>(&m, &rnd);
            let result = sk.pk.verify_internal_::<gamma1, gamma2, lambda, tau, beta>(&m, &sig);
            assert!(result);
        }
    }
}
